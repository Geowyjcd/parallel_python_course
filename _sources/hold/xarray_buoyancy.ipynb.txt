{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {
    "toc": true
   },
   "source": [
    "<h1>Table of Contents<span class=\"tocSkip\"></span></h1>\n",
    "<div class=\"toc\"><ul class=\"toc-item\"><li><span><a href=\"#install-xarray\" data-toc-modified-id=\"install-xarray-1\"><span class=\"toc-item-num\">1&nbsp;&nbsp;</span>install xarray</a></span><ul class=\"toc-item\"><li><span><a href=\"#First-load-a-couple-of-utility-functions\" data-toc-modified-id=\"First-load-a-couple-of-utility-functions-1.1\"><span class=\"toc-item-num\">1.1&nbsp;&nbsp;</span>First load a couple of utility functions</a></span></li></ul></li><li><span><a href=\"#Conditional-sampling-the-flux\" data-toc-modified-id=\"Conditional-sampling-the-flux-2\"><span class=\"toc-item-num\">2&nbsp;&nbsp;</span>Conditional sampling the flux</a></span></li></ul></div>"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# install xarray"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import glob\n",
    "import numpy as np\n",
    "import pdb"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "metadata": {},
   "outputs": [],
   "source": [
    "#!conda install -y xarray"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "******************************\n",
      "context imported. Front of path:\n",
      "/Users/phil/repos/parallel_python_course/notebooks\n",
      "\n",
      "******************************\n",
      "\n"
     ]
    }
   ],
   "source": [
    "import context\n",
    "from westgrid.data_read import download"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#get 10 files, each is the same timestep for a member of a\n",
    "#10 member ensemble\n",
    "import numpy as np\n",
    "root='http://clouds.eos.ubc.ca/~phil/docs/atsc500/dryles'\n",
    "for i in np.arange(1,11,dtype=np.int):\n",
    "    the_name='mar12014_{:d}_15600.nc'.format(i)\n",
    "    print(the_name)\n",
    "    url='{}/{}'.format(root,the_name)\n",
    "    download(the_name,root=root)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "metadata": {},
   "outputs": [],
   "source": [
    "#get 10 files, each is the same timestep for a member of a\n",
    "#10 member ensemble\n",
    "import numpy as np\n",
    "root=Path('/Users/phil/repos/atsc500/notebooks')\n",
    "the_files=root.glob('mar12*nc')\n",
    "# for i in np.arange(1,11,dtype=np.int):\n",
    "#     the_name='mar12014_{:d}_15600.nc'.format(i)\n",
    "#     print(the_name)\n",
    "#     url='{}/{}'.format(root,the_name)\n",
    "#     download(the_name,root=root)\n",
    "the_files=list(the_files)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Useful links:\n",
    "\n",
    "We need:\n",
    "\n",
    "* [namedtuples](https://docs.python.org/3/library/collections.html#collections.namedtuple)\n",
    "\n",
    "* [numpy.savez](http://docs.scipy.org/doc/numpy/reference/generated/numpy.savez.html)\n",
    "\n",
    "* [vapor](https://www.vapor.ucar.edu/)\n",
    "\n",
    "* [vapor videos](https://www.youtube.com/channel/UCVSuoneyeZFn4Znxl_jJ70A)\n",
    "\n",
    "* [xarray and dask](https://www.continuum.io/content/xray-dask-out-core-labeled-arrays-python)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## First load a couple of utility functions"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "metadata": {},
   "outputs": [],
   "source": [
    "import glob\n",
    "import xarray\n",
    "from matplotlib import pyplot as plt\n",
    "import numpy as np\n",
    "from collections import namedtuple\n",
    "import textwrap\n",
    "\n",
    "def sort_name(name):\n",
    "    \"\"\"\n",
    "      sort the filenames so '10' sorts\n",
    "      last by converting to integers\n",
    "    \"\"\"\n",
    "    str_name=str(name)\n",
    "    front, number, back = str_name.split('_')\n",
    "    return int(number)\n",
    "\n",
    "\n",
    "def dict_to_nt(the_dict, tupname):\n",
    "    \"\"\"\n",
    "      convert a dictionary into a namedtuple\n",
    "    \"\"\"\n",
    "    # first define the keys as attributes\n",
    "    In_tup = namedtuple(tupname, the_dict.keys())\n",
    "    # then read the key,value pairs in and assign to\n",
    "    # attributes\n",
    "    out_tuple = In_tup(**the_dict)\n",
    "    return out_tuple"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Now use xarray to stitch together the 10 ensemble members along a new \"virtual dimenstion\".\n",
    "The variable \"ds\"  is an xray dataset, which controls the reads/writes from the\n",
    "10 netcdf files\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "metadata": {},
   "outputs": [],
   "source": [
    "from netCDF4 import Dataset\n",
    "import os\n",
    "\n",
    "#how to completely copy a netcdf file\n",
    "\n",
    "def file_copy(infile):\n",
    "    outfile = Path() / Path('small_dir') / infile.name\n",
    "    with Dataset(str(infile), 'r') as ncin:\n",
    "        if outfile.exists():\n",
    "            os.remove(outfile)\n",
    "        #pdb.set_trace()\n",
    "        with Dataset(str(outfile), 'w') as ncout:\n",
    "\n",
    "    #first transfer the dimensions\n",
    "            xsize, ysize, zsize = 50, 40, 30\n",
    "            for name,value in ncin.dimensions.items():\n",
    "                if name=='x':\n",
    "                    the_size=xsize\n",
    "                elif name == 'y':\n",
    "                    the_size=ysize\n",
    "                elif name == 'z':\n",
    "                    the_size = zsize\n",
    "                else:\n",
    "                    the_size = value.size\n",
    "                #pdb.set_trace()\n",
    "                ncout.createDimension(name,the_size)\n",
    "\n",
    "            #next tranfer the global attributes\n",
    "\n",
    "            #pdb.set_trace()\n",
    "            for name,value in ncin.__dict__.items():\n",
    "                print(\"copying global attribute: \",name)\n",
    "                setattr(ncout,name,value)\n",
    "\n",
    "            #next transfer each variable and its attributes\n",
    "\n",
    "            for inname,invalue in ncin.variables.items():\n",
    "                print(\"copying variable: \",inname)\n",
    "                #pdb.set_trace()\n",
    "                #create the variable\n",
    "                the_dims=invalue.dimensions\n",
    "                if len(the_dims) == 4:\n",
    "                    the_dims = ('z','y','x')\n",
    "                outvar = ncout.createVariable(inname,invalue.dtype,the_dims)\n",
    "                #transfer the attributes\n",
    "                for (attname,attvalue) in invalue.__dict__.items():\n",
    "                    setattr(outvar,attname,attvalue.strip())\n",
    "                if inname == 'x':\n",
    "                    vals = ncin.variables[inname][:xsize]\n",
    "                elif inname == 'y':\n",
    "                    vals = ncin.variables[inname][:ysize]\n",
    "                elif inname == 'z':\n",
    "                    vals = ncin.variables[inname][:zsize]\n",
    "                elif inname == 'p':\n",
    "                    vals = ncin.variables[inname][:zsize]\n",
    "                else:\n",
    "                    ncvals = ncin.variables[inname]\n",
    "                    if len(ncvals.shape) == 4:\n",
    "                        vals = ncvals[0,:zsize,:ysize,:xsize]\n",
    "                    else:\n",
    "                        vals = ncvals[...]\n",
    "                try:\n",
    "                    outvar[...]=vals[...]\n",
    "                except IndexError:\n",
    "                    pdb.set_trace()\n",
    "                \n",
    "                #infile.variables[inname].getValue()\n",
    "                #finally, copy the data\n",
    "                #outvar.assignValue()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "/Users/phil/repos/atsc500/notebooks/mar12014_2_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_3_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_10_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_8_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_9_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_5_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_4_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_1_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_6_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n",
      "/Users/phil/repos/atsc500/notebooks/mar12014_7_15600.nc\n",
      "copying variable:  x\n",
      "copying variable:  y\n",
      "copying variable:  z\n",
      "copying variable:  time\n",
      "copying variable:  p\n",
      "copying variable:  U\n",
      "copying variable:  V\n",
      "copying variable:  W\n",
      "copying variable:  PP\n",
      "copying variable:  TABS\n",
      "copying variable:  QV\n"
     ]
    }
   ],
   "source": [
    "for a_file in the_files:\n",
    "    print(a_file)\n",
    "    file_copy(a_file)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "the_files.sort(key=sort_name)\n",
    "\n",
    "#\n",
    "#  put the 10 ensembles together along a new \"ens\" dimension\n",
    "#  using an xray multi-file dataset\n",
    "#\n",
    "#  Checkpointing\n",
    "#\n",
    "#  This is slow, so only do it once, and store the variables\n",
    "#  using np.savez.   Then set firstrun=False and read the \n",
    "#  variables out of the npz file instead of recalculating\n",
    "#\n",
    "#  Store the variables in a namedtuple so we don't have to continually\n",
    "#  be typing in dictionary indices  (too many keystrokes)\n",
    "#\n",
    "#\n",
    "firstrun = True\n",
    "if firstrun:\n",
    "    ds = xarray.open_mfdataset(the_files, engine='netcdf4', concat_dim='ens')\n",
    "    # dump the structure\n",
    "    print(ds)\n",
    "    #\n",
    "    #  3-d ensemble average for temp\n",
    "    #\n",
    "    x = ds['x']\n",
    "    y = ds['y']\n",
    "    z = ds['z']\n",
    "    temp = ds['TABS']\n",
    "    mean_temp = temp[:, 0, :, :, :].mean(dim='ens')\n",
    "    #\n",
    "    # same for velocity\n",
    "    #\n",
    "    wvel = ds['W']\n",
    "    mean_w = wvel[:, 0, :, :, :].mean(dim='ens')\n",
    "    #\n",
    "    # now look at the perturbation fields for one ensemble member\n",
    "    #\n",
    "    wvelprime = wvel[0, 0, :, :, :] - mean_w\n",
    "    Tprime = temp[0, 0, :, :, :] - mean_temp\n",
    "    flux_prime = wvelprime * Tprime\n",
    "    flux_profile = flux_prime.mean(dim='x').mean(dim='y')\n",
    "    keep_dict = dict(flux_prof=flux_profile, flux_prime=flux_prime.values,\n",
    "                     wvelprime=wvelprime.values, Tprime=Tprime.values, x=x, y=y, z=z)\n",
    "    np.savez('dump.npz', **keep_dict)\n",
    "    var_tup = dict_to_nt(keep_dict, 'vars')\n",
    "    print(var_tup._fields)\n",
    "else:\n",
    "    in_dict = np.load('dump.npz')\n",
    "    var_tup = dict_to_nt(in_dict, 'vars')\n",
    "    print(var_tup._fields)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig1, ax1 = plt.subplots(1, 1)\n",
    "ax1.plot(var_tup.flux_prof, var_tup.z)\n",
    "ax1.set(ylim=[0, 1000], title='Ens 0: vertically averaged kinematic heat flux',\n",
    "        ylabel='z (m)', xlabel='flux (K m/s)')\n",
    "\n",
    "fig2, ax2 = plt.subplots(1, 1)\n",
    "z200 = np.searchsorted(var_tup.z, 200)\n",
    "ax2.hist(var_tup.flux_prime[z200, :, :].flat)\n",
    "ax2.set(title='histogram of kinematic heat flux (K m/s) at z=200 m')\n",
    "\n",
    "fig3, ax3 = plt.subplots(1, 1)\n",
    "ax3.hist(var_tup.wvelprime[z200, :, :].flat)\n",
    "ax3.set(title=\"histogram of wvel' at 200 m\")\n",
    "\n",
    "fig4, ax4 = plt.subplots(1, 1)\n",
    "ax4.hist(var_tup.Tprime[z200, :, :].flat)\n",
    "ax4.set(title=\"histogram ot T' at z=200 m\");\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Conditional sampling the flux\n",
    "\n",
    "Write 100 where there is postively buoyant ascending air and 1 everywhere else\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "hit = np.logical_and(var_tup.wvelprime > 0, var_tup.Tprime > 0)\n",
    "\n",
    "pos_buoyant = np.ones_like(var_tup.flux_prime, dtype=np.float32)\n",
    "#pos_buoyant[hit] = var_tup.flux_prime[hit]\n",
    "pos_buoyant[hit] = pos_buoyant[hit]*100."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.4"
  },
  "toc": {
   "nav_menu": {},
   "number_sections": true,
   "sideBar": false,
   "skip_h1_title": false,
   "title_cell": "Table of Contents",
   "title_sidebar": "Contents",
   "toc_cell": true,
   "toc_position": {},
   "toc_section_display": "block",
   "toc_window_display": false
  }
 },
 "nbformat": 4,
 "nbformat_minor": 1
}
